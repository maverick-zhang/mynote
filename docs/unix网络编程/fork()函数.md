## fork()函数

------

在unix系统中，所有的进程都由其他的进程通过fork()函数，进程id为0的进程为系统调度用的进程，进程id为1的进程为init进程，即为所有进程的父进程。

fork进程调用一次返回两次，调用的进程称为父进程，fork()产生的进程称为子进程。fork函数的特俗之处在于函数会在父进程和子进程分别返回一次，这是因为子进程在fork函数调用之后会“拷贝父进程所拥有的内存”（实际上为了提高效率，子进程会和父进程共用内存，当数据要发生改变时再进行拷贝，即写时复制），子进程从fork函数处开始执行，该函数在子进程中返回0，在父进程中返回子进程的进程id。fork函数后续的代码由父进程先执行和子进程先执行是不确定的。

fork函数失败的情况：

- 超过最大进程数32767
- 线程超过单个用户所允许的最大值_SC_CHILD_MAX = 7788

当子进程结束时，父进程会接收一个SIGCHLD信号(changed)，但是如果此时父进程 还在执行，但是父进程未调用wait和waitpid函数来处理，那么子进程会成为僵死进程(状态符为Z)。处理该僵死进程的方法之一为杀死父进程。但是为了避免僵死进程的产生，必须处理SIGCHLD信号。

#### waitpid(pid_t, &status, WNOHANG)函数

- 第一个参数表示等待的进程id，-1表示等待所有的进程，一旦有任一子进程产生了SIGCHLD信号，waitpid都会返回，否则函数会阻塞。WNOHANG表示不等待直接返回，常在信号处理函数中设置该标记，因为在信号处理函数中SIGCHLD信号一定已经产生了。

 

