## 文件IO

### 标准io

#### write函数

对于多进程共享文件同时进行写入时, 如果进程是父子进程, 文件描述符通过复制共享, 那么在写文件时输出的文件不会发生错乱, wirte是原子操作, 不会出现行与行的重叠.实际上父子进程共享了文件表项, 共用一个偏移指针, 所以不会错乱.

而若两个无关的进程同时向文件写入, 则可能出现问题

#### fwrite

这和函数时语言提供的, write时操作系统提供的,这个函数会在用户缓冲区和内核缓冲区之间在加了一层clib缓冲区, 其最终还是调用write. 优先考虑系统调用函数.open和fopen类似. 系统函数调用都保证了原子操作, 



### write写的安全问题

当write函数返回时, 内核已经将应用程序缓冲区所提供的数据放到了内核的缓冲区,但是无法保证实际此时已经写入磁盘, 因为文件io速度比较慢, 所以系统采取了异步操作.

掉电导致write写入丢失的情况, 对于特俗的数据,可以通过直接访问物理磁盘(O_DIRECT), 从而绕过内核缓存区,这是只要write返回,即写入成功.或者在open文件时使用O_SYNC选项,此时表示内核缓冲区的内容会立即写入. 但是这两种方法都提高了写入的频率,降低了写入速度.

缓存同步:尽量保证缓存数据和写入磁盘的数据一致

sync(void): 将所有修改过的缓冲区排入写队列,然后返回,并不保证是否写入磁盘

fsync(int fd):把fd的文件缓冲区立即写入磁盘,并不等待磁盘操作借宿返回

fdatasync(int fd): 类似fsync, 但只影响文件的数据部分,而fsync还会同步更新文件的属性

使用方法:

wirte(4k) 1000次write调用一次fsync