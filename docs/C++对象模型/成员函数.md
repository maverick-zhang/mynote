函数调用

c++在设计时规定类的普通成员函数的调用速度不慢于全局函数的调用，因此编译器把对成员函数的调用转换为对全局函数的调用。成员函数有独立的内存地址(通过&类名::函数名，获取成员函数的地址)，且在编译时由编译器确定其内存地址。编译器会给每一个成员函数增加一个 this指针参数，并且给每一个成员变量的使用都通过this指针。

虚函数的调用：

1. 通过对象调用虚成员函数：不需要通过虚函数表，因为不涉及到多态问题。
2. 使用对象指针调用虚成员函数：通过虚函数表调用虚函数(ptr->vptr\[0](this, xxx))
3. 成员函数中调用虚函数，也会通过虚函数表去调用该虚函数。可以使用类名::虚函数名明确指定调用的函数，这样就可以直接通过函数地址进行调用。

静态成员函数：

1.    可以通过类名，对象以及对象 指针进行调用，都被转换为全局函数的调用，且静态函数不需要传递this指针，即可以通过把空指针转为类指针调用该静态函数((myclass*)0)->static_func();静态成员函数不能使用非静态成员变量。
2. 静态成员函数不能设置为virtual或const函数
3. 静态成员函数等同于非成员函数。在需要回调函数的场合可以把静态成员函数作为回掉函数。 

vcall thunk:

1. vcall thunk为一段汇编代码块，可以调整this指针
2. 功能为跳转到要调用的虚函数
3. 也可以把vcall看做虚函数表vcall[0]代表虚函数表的第一个函数地址，vcall[4]为第二个函数地址(假设指针的大小为4个字节)
4. &MyClass::mem_vir_func 这样获得的虚函数地址，不是真正的虚函数地址，实际上存储的是一个偏移值，通过这个偏移值来获得实际的虚函数地址。

成员函数指针：

1. 成员函数地址在编译时就已经确定，但是调用需要依赖于对象，因为成员函数默认会传入一个this指针

2. 创建成员函数指针 return_type (class_name::*my_ptr)(args_type arg) = &class_name::member_func

   ```c++
   A obj_a;
   
   void (A::*ptr)(int val) = &A::mem_func; //创建成员函数指针
   (obj_a.*ptr)(15); //通过成员和成员函数指针调用该成员函数(感觉有点多此一举。。。。)
   ```

3. 成员函数调用静态成员函数，可以直接把静态函数看做普通函数。

   ```c++
   void (*func_ptr)(int val) = &A::static_func;  //创建静态成员函数指针
   func_ptr(20); //调用函数
   ```

4. 指向虚成员函数的指针，使用方法和普通成员函数类似。 (虽然使用了函数指针，但是依然通过虚函数表来调用)

5. 成员函数指针里，保存的可能是真正的函数地址，也可能是vcall地址 

6. 涉及继承时，具体调用哪个虚函数，由传入的this的类型决定。

代码优化： 编译器在编译期间可能进行一些计算来优化代码。对于参数固定的函数调用，编译器视为一种不变的表达式

 