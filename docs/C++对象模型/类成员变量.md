##  类成员变量

------

### 进程内存空间布局

​	当运行一个可执行文件时，操作系统会把可执行文件加载到内存，然后给进程分配一个虚拟内存空间

![2020-02-25 23-00-55屏幕截图](../static/2020-02-25%2023-00-55%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png)

数据段：全局量      BSS：未初始化的全局数据   堆：运行时数据分配的空间  栈(堆栈)：局部变量

类静态成员变量不占用对象的空间，其存储在程序的数据段。其他普通成员在对象中存储的顺序由定义的顺序决定(先定义的内存地址号小)。 

#### 内存边界调整（字节对齐）

在成员之间添加一些空字节，以使得字节数符合4或8的倍数。目的：提高运行效率，由编译器执行。为了使数据能够跨平台使用，可以使用1字节对齐，即取消字节对齐。#pragma pack(1), 在次使用取消1字节对齐。

#### 成员变量的偏移值

成员变量的地址相对对象首地址的偏移量。使用&MyClass::member_var来获取偏移量，或使用

```c++
#define GET(A, m) (int) ((&(A*)0)->m)
```

linux下shell命令nm可以查看程序各种数据的存放位置

编译器在编译时，当读取到所有类的成员变量的定义之后，才去解析类的成员函数，因此对于成员函数来说，如果内部使用了某成员变量，那么该变量一定是定义过的。而对于成员函数的形参，如果形参的类型是自定义的类型，如果不幸存在重名，那么编译器把成员函数的参数设定为第一次遇到该类型定义时的定义。因此对于typedef这种类型定义，要放在程序 的最靠前的位置，方便编译器进行解析。



