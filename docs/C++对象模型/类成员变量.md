##  类成员变量

------

### 进程内存空间布局

​	当运行一个可执行文件时，操作系统会把可执行文件加载到内存，然后给进程分配一个虚拟内存空间

![2020-02-25 23-00-55屏幕截图](../static/2020-02-25%2023-00-55%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png)

数据段：全局量      BSS：未初始化的全局数据   堆：运行时数据分配的空间  栈(堆栈)：局部变量

类静态成员变量不占用对象的空间，其存储在程序的数据段。其他普通成员在对象中存储的顺序由定义的顺序决定(先定义的内存地址号小)。 

#### 内存边界调整（字节对齐）

在成员之间添加一些空字节，以使得字节数符合4或8的倍数。目的：提高运行效率，由编译器执行。为了使数据能够跨平台使用，可以使用1字节对齐，即取消字节对齐。#pragma pack(1), 在次使用取消1字节对齐。

#### 成员变量的偏移值

成员变量的地址相对对象首地址的偏移量。使用&MyClass::member_var来获取偏移量，或使用

```c++
#define GET(A, m) (int) ((&(A*)0)->m)
```

linux下shell命令nm可以查看程序各种数据的存放位置。对于单继承的类，父类成员的空间布局在子类成员之前，且按父类成员的定义顺序确定，父类成员和子类成员的边界处会进行对齐处理，因此引入继承后可能会导致内存空间变大，编译器可能会采取一定的优化来减少因为边界调整而导致的空间增大，内存拷贝要谨慎。

编译器在编译时，当读取到所有类的成员变量的定义之后，才去解析类的成员函数，因此对于成员函数来说，如果内部使用了某成员变量，那么该变量一定是定义过的。而对于成员函数的形参，如果形参的类型是自定义的类型，如果不幸存在重名，那么编译器把成员函数的参数设定为第一次遇到该类型定义时的定义。因此对于typedef这种类型定义，要放在程序 的最靠前的位置，方便编译器进行解析。



#### 静态成员和非静态成员

类的静态成员变量可以当做全局变量，但是只在类的空间可用，使用时类名::变量名来使用，或者通过对象来获取该静态成员。静态成员只有一个实体，保存在可执行文件的数据段。静态成员需要声明和定义才能使用。

对于普通数据成员的访问，编译器时把类对象的首地址加上成员变量的偏移值进行访问的。其在编译是即确定，因此在执行时效率很高。



#### 继承个this指针调整

对于有虚函数的情况下，虚函数表指针占用4字节内存，因此this指针要进行相应的调整才能够根据偏移值来正确获取到对象成员变量。多继承时，若父类均有虚函数，那么子类将会有多个虚函数表指针，第一个父类的虚函数表指针放在最前(且和子类虚函数表指针共用同一个虚函数表，即子类的新虚函数会放在该表中)，然后时第一个父类的数据成员，再其后是第二个父类的虚函数表指针，一次类推。因此对于多重继承，切记不要使用第二个父类指针进行new和delete操作，会出现异常，因为此时new返回的地址并不是对象真正的首地址。

